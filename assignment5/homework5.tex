\documentclass[12pt]{article}

\usepackage{verbatim}
\usepackage{listings}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{qtree}
\usepackage{enumerate}
\usepackage{changepage}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usepackage{subfigure}
\usepackage{pgfplots}

\usepackage{enumitem}
\setdescription{leftmargin=\parindent,labelindent=\parindent}
\setlist[enumerate,1]{label=\alph*}

\usepackage[utf8]{inputenc}

\title{CS325 Winter 2013: HW 5}
\author{
    Daniel Reichert \\
    Trevor Bramwell \\
}
\date{\today}

\newcommand{\BigO}[1]{\ensuremath{O(#1)}}

% Big O: \BigO
% Big Omega: \Omega
% Big Theta: \Theta

% Examples:
%
%   $\BigO{n}$
%   $\Omega(n\log{n})$
%   $\Theta(\log{2n})$


\begin{document}
\maketitle
\section*{1}
\paragraph{Problem:}
We will review proof by induction in this problem. Specifically, consider the
stoogesort algorithm for sorting and use proof by induction to show that this
algorithm correctly sorts an given array into increasing order.
\begin{lstlisting}[mathescape]
STOOGESORT(A[0...n-1])
    if n = 2 and A[0] > A[1]
        swap A[0] and A[1]
    else if n > 2
        k = 2n/3
        STOOGESORT(A[0...k-1])
        STOOGESORT(A[n-k...n-1])
        STOOGESORT(A[0...k-1])
\end{lstlisting}
\paragraph{Solution:}

\section*{2}
\paragraph{6.17 from book:}
Given an unlimited supply of coins of denominations $x_1 , x_2 , . . . , x_n$,
we wish to make change for a value $v$; that is, we wish to find a set of coins
whose total value is $v$. This might not be possible: for instance, if the
denominations are 5 and 10 then we can make change for 15 but not for 12.
Give an $\BigO{nv}$ dynamic-programming algorithm for the following problem.
Input: $x_1 , . . . , x_n ; v$.
Question: Is it possible to make change for $v$ using coins of denominations
 $x_1 , . . . , x_n$ ?
\paragraph{Solution:}


\section*{3}
\paragraph{Problem:}
Additional question on 6.17. Show how one can reduce the problem specified by
6.17 into a knapsack problem (with repetition). Reducing to knapsack problem
means that for any instance of the coin-change problem specified in 6.17, we
can turn it into a knapsack problem, and apply an algorithm for knapsack, and
use its solution to decide the solution for the original coin change problem.
\paragraph{Solution:}

\section*{4}
\paragraph{6.26 from book:}
Sequence alignment. When a new gene is discovered, a standard approach to
understanding its function is to look through a database of known genes and
find close matches. The closeness of two genes is measured by the extent to 
which they are aligned. To formalize this, think of a gene as being a long
string over an alphabet Σ = {A, C, G, T }. Consider two genes (strings)
x = AT GCC and y = T ACGCA. An alignment of x and y is a way of matching up
these two strings by writing them in columns, for instance:

$_AT_GCC$
$TA_CGCA$

Here the “−” indicates a “gap.” The characters of each string must appear
in order, and each column must contain a character from at least one of 
the strings. The score of an alignment is specified by a scoring matrix δ
of size (|Σ| + 1) × (|Σ| + 1), where the extra row and column are to
accommodate gaps. For instance the preceding alignment has the following score:
δ(−, T ) + δ(A, A) + δ(T, −) + δ(−, C) + δ(G, G) + δ(C, C) + δ(C, A).

Give a dynamic programming algorithm that takes as input two strings $x[1 . . . n]$ and $y[1 . . . m]$ and a scoring matrix δ, and returns the highest-scoring alignment. The running time should be $\BigO(mn)$.

\paragraph{Solution:}

\end{document}
